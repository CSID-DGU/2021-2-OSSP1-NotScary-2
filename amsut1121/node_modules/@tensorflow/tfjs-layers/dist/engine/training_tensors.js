/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * Interfaces and methods for training models using tf.Tensor objects.
 */
import * as tfc from '@tensorflow/tfjs-core';
import { Tensor, tensor1d, util } from '@tensorflow/tfjs-core';
import { expandDims, gather, sliceAlongFirstAxis } from '../backend/tfjs_backend';
import { configureCallbacks, standardizeCallbacks } from '../base_callbacks';
import { NotImplementedError, ValueError } from '../errors';
import { disposeTensorsInLogs } from '../logs';
import { range } from '../utils/math_utils';
export function checkBatchSize(batchSize) {
    tfc.util.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
}
/**
 * Slice a Tensor or an Array of Tensors, by start and stop indices.
 *
 * Porting Note: The `_slice_arrays` function in PyKeras is covered by this
 *   function and `sliceArraysByIndices()` together.
 *
 * @param arrays: the input.
 * @param start: the starting index (inclusive).
 * @param stop: the stopping index (exclusive).
 * @returns The result of the slicing. If `arrays` is an `Array` of
 *   `tf.Tensor`s, the slicing will be applied to all elements of the `Array`
 *   in the same way.
 */
export function sliceArrays(arrays, start, stop) {
    if (arrays == null) {
        return [null];
    }
    else if (Array.isArray(arrays)) {
        return arrays.map(array => sliceAlongFirstAxis(array, start, stop - start));
    }
    else { // Tensor.
        return sliceAlongFirstAxis(arrays, start, stop - start);
    }
}
/**
 * Slice a Tensor or an Array of Tensors, by random-order indices.
 *
 * Porting Note: The `_slice_arrays` function in PyKeras is covered by this
 *   function and `sliceArrays()` together.
 *
 * @param arrays The input `tf.Tensor` or `Array` of `tf.Tensor`s to slice.
 *   If an `Array` of `tf.Tensor`s, all `tf.Tensor`s will be sliced in the
 *   same fashion.
 * @param indices The indices to use for slicing along the first (batch)
 *   dimension.
 * @returns Result(s) of the slicing.
 */
export function sliceArraysByIndices(arrays, indices) {
    return tfc.tidy(() => {
        if (arrays == null) {
            return null;
        }
        else if (Array.isArray(arrays)) {
            return arrays.map(array => sliceArraysByIndices(array, indices));
        }
        else {
            // TODO(cais): indices should be a pre-constructed Tensor1D to avoid
            //   tensor1d() calls.
            return gather(arrays, indices.dtype === 'int32' ? indices : tfc.cast(indices, 'int32'));
        }
    });
}
/**
 * Returns a list of batch indices (tuples of indices).
 * @param size: Integer, total size of the data to slice into batches.
 * @param batchSize: Integer, batch size.
 * @returns An Array of [batchStart, batchEnd] tuples. batchStart is
 *   inclusive; batchEnd is exclusive. I.e., each batch consists of indices x
 *   that satisfy batchStart <= x < batchEnd.
 */
export function makeBatches(size, batchSize) {
    const output = [];
    let batchStart = 0;
    let batchEnd = null;
    while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
            batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
    }
    return output;
}
/**
 * Abstract fit function for `f(ins)`.
 * @param f A Function returning a list of tensors. For training, this
 *   function is expected to perform the updates to the variables.
 * @param ins List of tensors to be fed to `f`.
 * @param outLabels List of strings, display names of the outputs of `f`.
 * @param batchSize Integer batch size or `== null` if unknown. Default : 32.
 * @param epochs Number of times to iterate over the data. Default : 1.
 * @param verbose Verbosity mode: 0, 1, or 2. Default: 1.
 * @param callbacks List of callbacks to be called during training.
 * @param valF Function to call for validation.
 * @param valIns List of tensors to be fed to `valF`.
 * @param shuffle Whether to shuffle the data at the beginning of every
 * epoch. Default : true.
 * @param callbackMetrics List of strings, the display names of the metrics
 *   passed to the callbacks. They should be the concatenation of the
 *   display names of the outputs of `f` and the list of display names
 *   of the outputs of `valF`.
 * @param initialEpoch Epoch at which to start training (useful for
 *   resuming a previous training run). Default : 0.
 * @param stepsPerEpoch Total number of steps (batches on samples) before
 *   declaring one epoch finished and starting the next epoch. Ignored with
 *   the default value of `undefined` or `null`.
 * @param validationSteps Number of steps to run validation for (only if
 *   doing validation from data tensors). Not applicable for tfjs-layers.
 * @returns A `History` object.
 */
async function fitLoop(
// Type `model` as `any` here to avoid circular dependency w/ training.ts.
// tslint:disable-next-line:no-any
model, f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
    if (batchSize == null) {
        batchSize = 32;
    }
    if (epochs == null) {
        epochs = 1;
    }
    if (shuffle == null) {
        shuffle = true;
    }
    if (initialEpoch == null) {
        initialEpoch = 0;
    }
    // TODO(cais): Change const to let below when implementing validation.
    let doValidation = false;
    if (valF != null && valIns != null) {
        doValidation = true;
        // TODO(cais): verbose message.
    }
    if (validationSteps != null) {
        doValidation = true;
        if (stepsPerEpoch == null) {
            throw new ValueError('Can only use `validationSteps` when doing step-wise training, ' +
                'i.e., `stepsPerEpoch` must be set.');
        }
    }
    const numTrainSamples = model.checkNumSamples(ins, batchSize, stepsPerEpoch, 'steps_per_epoch');
    let indexArray;
    if (numTrainSamples != null) {
        indexArray = range(0, numTrainSamples);
    }
    if (verbose == null) {
        verbose = 1;
    }
    const { callbackList, history } = configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);
    callbackList.setModel(model);
    model.history = history;
    await callbackList.onTrainBegin();
    model.stopTraining_ = false;
    // TODO(cais): Take care of callbacks.validation_data as in PyKeras.
    // TODO(cais): Pre-convert feeds for performance as in PyKeras.
    for (let epoch = initialEpoch; epoch < epochs; ++epoch) {
        await callbackList.onEpochBegin(epoch);
        const epochLogs = {};
        if (stepsPerEpoch != null) {
            throw new NotImplementedError('stepsPerEpoch mode is not implemented yet.');
        }
        else {
            if (shuffle === 'batch') {
                throw new NotImplementedError('batch shuffling is not implemneted yet');
            }
            else if (shuffle) {
                util.shuffle(indexArray);
            }
            // Convert the potentially shuffled indices to Tensor1D, to avoid the
            // cost of repeated creation of Array1Ds later on.
            const epochIndexArray1D = tensor1d(indexArray);
            const batches = makeBatches(numTrainSamples, batchSize);
            for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                const batchLogs = {};
                await callbackList.onBatchBegin(batchIndex, batchLogs);
                tfc.tidy(() => {
                    const batchStart = batches[batchIndex][0];
                    const batchEnd = batches[batchIndex][1];
                    const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);
                    batchLogs['batch'] = batchIndex;
                    batchLogs['size'] = batchEnd - batchStart;
                    // TODO(cais): In ins, train flag can be a number, instead of an
                    //   Tensor? Do we need to handle this in tfjs-layers?
                    const insBatch = sliceArraysByIndices(ins, batchIds);
                    const outs = f(insBatch);
                    for (let i = 0; i < outLabels.length; ++i) {
                        const label = outLabels[i];
                        const out = outs[i];
                        batchLogs[label] = out;
                        tfc.keep(out);
                        // TODO(cais): Use scope() to avoid ownership.
                    }
                    if (batchIndex === batches.length - 1) { // Last batch.
                        if (doValidation) {
                            const valOuts = model.testLoop(valF, valIns, batchSize);
                            // Porting Notes: In tfjs-layers, valOuts is always an Array.
                            for (let i = 0; i < outLabels.length; ++i) {
                                const label = outLabels[i];
                                const out = valOuts[i];
                                tfc.keep(out);
                                // TODO(cais): Use scope() to avoid ownership.
                                epochLogs['val_' + label] = out;
                            }
                        }
                    }
                });
                await callbackList.onBatchEnd(batchIndex, batchLogs);
                disposeTensorsInLogs(batchLogs);
                if (model.stopTraining_) {
                    break;
                }
                // TODO(cais): return outs as list of Tensor.
            }
            epochIndexArray1D.dispose();
        }
        // TODO(cais): Run validation at the end of the epoch.
        await callbackList.onEpochEnd(epoch, epochLogs);
        if (model.stopTraining_) {
            break;
        }
    }
    await callbackList.onTrainEnd();
    await model.history.syncData();
    return model.history;
}
export async function fitTensors(
// Type `model` as `any` here to avoid circular dependency w/ training.ts.
// tslint:disable-next-line:no-any
model, x, y, args = {}) {
    if (model.isTraining) {
        throw new Error('Cannot start training because another fit() call is ongoing.');
    }
    model.isTraining = true;
    let inputs;
    let targets;
    let inputValX;
    let inputValY;
    let valX;
    let valY;
    let sampleWeights;
    try {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        // Validate user data.
        // TODO(cais): Support sampleWeight.
        const checkBatchAxis = false;
        const standardizedOuts = await model.standardizeUserData(x, y, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);
        inputs = standardizedOuts[0];
        targets = standardizedOuts[1];
        sampleWeights = standardizedOuts[2];
        // Prepare validation data.
        let doValidation = false;
        let valIns;
        if (args.validationData != null && args.validationData.length > 0) {
            doValidation = true;
            if (args.validationData.length === 2) {
                // config.validationData consists of valX and valY.
                inputValX = args.validationData[0];
                inputValY = args.validationData[1];
            }
            else if (args.validationData.length === 3) {
                throw new NotImplementedError('validationData including sample weights is not supported yet.');
            }
            else {
                throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) ` +
                    `or 3 (valX, valY, valSampleWeight) items; ` +
                    `${args.validationData} is invalid.`);
            }
            const checkBatchAxis = true;
            const valStandardized = await model.standardizeUserData(inputValX, inputValY, null, /** Unused sample weights. */ null, /** Unused class weights. */ checkBatchAxis, batchSize);
            valX = valStandardized[0];
            valY = valStandardized[1];
            valIns = valX.concat(valY);
            // TODO(cais): Add useLearningPhase data properly.
        }
        else if (args.validationSplit != null && args.validationSplit > 0 &&
            args.validationSplit < 1) {
            doValidation = true;
            // Porting Note: In tfjs-layers, inputs[0] is always a Tensor.
            const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));
            const originalBatchSize = inputs[0].shape[0];
            valX = sliceArrays(inputs, splitAt, originalBatchSize);
            inputs = sliceArrays(inputs, 0, splitAt);
            valY = sliceArrays(targets, splitAt, originalBatchSize);
            targets = sliceArrays(targets, 0, splitAt);
            // TODO(cais): Once sampleWeights becomes available, slice it to get
            //   valSampleWeights.
            valIns = valX.concat(valY);
            // TODO(cais): Add useLearningPhase data properly.
        }
        else if (args.validationSteps != null) {
            doValidation = true;
            // TODO(cais): Add useLearningPhase.
        }
        const ins = inputs.concat(targets).concat(sampleWeights);
        model.checkTrainableWeightsConsistency();
        // TODO(cais): Handle use_learning_phase and learning_phase?
        // Porting Note: Here we see a key deviation of tfjs-layers from
        // Keras.
        //  Due to the imperative nature of tfjs-layers' backend (tfjs-core),
        //  we do not construct symbolic computation graphs to embody the
        //  training process. Instead, we define a function that performs the
        //  training action. In PyKeras, the data (inputs and targets) are fed
        //  through graph placeholders. In tfjs-layers, the data are fed as
        //  function arguments. Since the function are defined below in the
        //  scope, we don't have equivalents of PyKeras's
        //  `_make_train_funciton`.
        const trainFunction = model.makeTrainFunction();
        const outLabels = model.getDedupedMetricsNames();
        let valFunction;
        let callbackMetrics;
        if (doValidation) {
            model.makeTestFunction();
            valFunction = model.testFunction;
            callbackMetrics =
                outLabels.slice().concat(outLabels.map(n => 'val_' + n));
        }
        else {
            valFunction = null;
            valIns = [];
            callbackMetrics = outLabels.slice();
        }
        const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);
        const out = await fitLoop(model, trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);
        return out;
    }
    finally {
        model.isTraining = false;
        // Memory clean up.
        disposeNewTensors(inputs, x);
        disposeNewTensors(targets, y);
        disposeNewTensors(valX, inputValX);
        disposeNewTensors(valY, inputValY);
        if (sampleWeights != null) {
            tfc.dispose(sampleWeights);
        }
    }
    // TODO(cais): Add value to outLabels.
}
/**
 * Ensure tensors all have a rank of at least 2.
 *
 * If a tensor has a rank of 1, it is dimension-expanded to rank 2.
 * If any tensor has a rank of 0 (i.e., is a scalar), an error will be thrown.
 */
export function ensureTensorsRank2OrHigher(tensors) {
    const outs = [];
    if (tensors instanceof Tensor) {
        tensors = [tensors];
    }
    // Make Tensors at least 2D.
    for (let i = 0; i < tensors.length; ++i) {
        const tensor = tensors[i];
        if (tensor.rank === 1) {
            outs.push(expandDims(tensor, 1));
        }
        else if (tensor.rank === 0) {
            throw new Error('Expected tensor to be at least 1D, but received a 0D tensor ' +
                '(scalar).');
        }
        else {
            outs.push(tensor);
        }
    }
    return outs;
}
/**
 * Compare a set of tensors with a reference (old) set, discard the ones
 * in the new set that are not present in the reference set.
 *
 * This method is used for memory clenaup during calls such as
 * LayersModel.fit().
 *
 * @param tensors New set which may contain Tensors not present in
 *   `refTensors`.
 * @param refTensors Reference Tensor set.
 */
// TODO(cais, kangyizhang): Deduplicate with tfjs-data.
export function disposeNewTensors(tensors, refTensors) {
    if (tensors == null) {
        return;
    }
    const oldTensorIds = [];
    if (refTensors instanceof Tensor) {
        oldTensorIds.push(refTensors.id);
    }
    else if (Array.isArray(refTensors)) {
        refTensors.forEach(t => oldTensorIds.push(t.id));
    }
    else if (refTensors != null) {
        // `oldTensors` is a map from string name to Tensor.
        for (const name in refTensors) {
            const oldTensor = refTensors[name];
            oldTensorIds.push(oldTensor.id);
        }
    }
    const tensorsToDispose = [];
    if (tensors instanceof Tensor) {
        if (oldTensorIds.indexOf(tensors.id) === -1) {
            tensorsToDispose.push(tensors);
        }
    }
    else if (Array.isArray(tensors)) {
        tensors.forEach(t => {
            if (oldTensorIds.indexOf(t.id) === -1) {
                tensorsToDispose.push(t);
            }
        });
    }
    else if (tensors != null) {
        // `oldTensors` is a map from string name to Tensor.
        for (const name in tensors) {
            const tensor = tensors[name];
            if (oldTensorIds.indexOf(tensor.id) === -1) {
                tensorsToDispose.push(tensor);
            }
        }
    }
    tensorsToDispose.forEach(t => {
        if (!t.isDisposed) {
            t.dispose();
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdGVuc29ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfdGVuc29ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQVMsTUFBTSxFQUFZLFFBQVEsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUvRSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ2hGLE9BQU8sRUFBZSxrQkFBa0IsRUFBc0Qsb0JBQW9CLEVBQW9CLE1BQU0sbUJBQW1CLENBQUM7QUFDaEssT0FBTyxFQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMxRCxPQUFPLEVBQUMsb0JBQW9CLEVBQWlCLE1BQU0sU0FBUyxDQUFDO0FBQzdELE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQTRJMUMsTUFBTSxVQUFVLGNBQWMsQ0FBQyxTQUFpQjtJQUM5QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FDWCxTQUFTLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQzVDLEdBQUcsRUFBRSxDQUFDLDJEQUNGLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3ZCLE1BQXVCLEVBQUUsS0FBYSxFQUFFLElBQVk7SUFDdEQsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNmO1NBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0s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Y2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogSW50ZXJmYWNlcyBhbmQgbWV0aG9kcyBmb3IgdHJhaW5pbmcgbW9kZWxzIHVzaW5nIHRmLlRlbnNvciBvYmplY3RzLlxuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtTY2FsYXIsIFRlbnNvciwgVGVuc29yMUQsIHRlbnNvcjFkLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2V4cGFuZERpbXMsIGdhdGhlciwgc2xpY2VBbG9uZ0ZpcnN0QXhpc30gZnJvbSAnLi4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtCYXNlQ2FsbGJhY2ssIGNvbmZpZ3VyZUNhbGxiYWNrcywgQ3VzdG9tQ2FsbGJhY2tBcmdzLCBIaXN0b3J5LCBNb2RlbExvZ2dpbmdWZXJib3NpdHksIHN0YW5kYXJkaXplQ2FsbGJhY2tzLCBZaWVsZEV2ZXJ5T3B0aW9uc30gZnJvbSAnLi4vYmFzZV9jYWxsYmFja3MnO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtkaXNwb3NlVGVuc29yc0luTG9ncywgVW5yZXNvbHZlZExvZ3N9IGZyb20gJy4uL2xvZ3MnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnLi4vdXRpbHMvbWF0aF91dGlscyc7XG5pbXBvcnQge0NsYXNzV2VpZ2h0LCBDbGFzc1dlaWdodE1hcH0gZnJvbSAnLi90cmFpbmluZ191dGlscyc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGNvbmZpZ3VyYXRpb24gbW9kZWwgdHJhaW5pbmcgYmFzZWQgb24gZGF0YSBhcyBgdGYuVGVuc29yYHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxGaXRBcmdzIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiBzYW1wbGVzIHBlciBncmFkaWVudCB1cGRhdGUuIElmIHVuc3BlY2lmaWVkLCBpdFxuICAgKiB3aWxsIGRlZmF1bHQgdG8gMzIuXG4gICAqL1xuICBiYXRjaFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEludGVnZXIgbnVtYmVyIG9mIHRpbWVzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgdHJhaW5pbmcgZGF0YSBhcnJheXMuXG4gICAqL1xuICBlcG9jaHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFZlcmJvc2l0eSBsZXZlbC5cbiAgICpcbiAgICogRXhwZWN0ZWQgdG8gYmUgMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAgICpcbiAgICogMCAtIE5vIHByaW50ZWQgbWVzc2FnZSBkdXJpbmcgZml0KCkgY2FsbC5cbiAgICogMSAtIEluIE5vZGUuanMgKHRmanMtbm9kZSksIHByaW50cyB0aGUgcHJvZ3Jlc3MgYmFyLCB0b2dldGhlciB3aXRoXG4gICAqICAgICByZWFsLXRpbWUgdXBkYXRlcyBvZiBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzIGFuZCB0cmFpbmluZyBzcGVlZC5cbiAgICogICAgIEluIHRoZSBicm93c2VyOiBubyBhY3Rpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIDIgLSBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgKi9cbiAgdmVyYm9zZT86IE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eTtcblxuICAvKipcbiAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIGR1cmluZyB0cmFpbmluZy5cbiAgICogQ2FuIGhhdmUgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBjYWxsYmFja3M6XG4gICAqICAgLSBgb25UcmFpbkJlZ2luKGxvZ3MpYDogY2FsbGVkIHdoZW4gdHJhaW5pbmcgc3RhcnRzLlxuICAgKiAgIC0gYG9uVHJhaW5FbmQobG9ncylgOiBjYWxsZWQgd2hlbiB0cmFpbmluZyBlbmRzLlxuICAgKiAgIC0gYG9uRXBvY2hCZWdpbihlcG9jaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYG9uRXBvY2hFbmQoZXBvY2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guXG4gICAqICAgLSBgb25CYXRjaEJlZ2luKGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgb25CYXRjaEVuZChiYXRjaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBiYXRjaC5cbiAgICogICAtIGBvbllpZWxkKGVwb2NoLCBiYXRjaCwgbG9ncylgOiBjYWxsZWQgZXZlcnkgYHlpZWxkRXZlcnlgIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgIHdpdGggdGhlIGN1cnJlbnQgZXBvY2gsIGJhdGNoIGFuZCBsb2dzLiBUaGUgbG9ncyBhcmUgdGhlIHNhbWVcbiAgICogICAgICBhcyBpbiBgb25CYXRjaEVuZCgpYC4gTm90ZSB0aGF0IGBvbllpZWxkYCBjYW4gc2tpcCBiYXRjaGVzIG9yXG4gICAqICAgICAgZXBvY2hzLiBTZWUgYWxzbyBkb2NzIGZvciBgeWllbGRFdmVyeWAgYmVsb3cuXG4gICAqL1xuICBjYWxsYmFja3M/OiBCYXNlQ2FsbGJhY2tbXXxDdXN0b21DYWxsYmFja0FyZ3N8Q3VzdG9tQ2FsbGJhY2tBcmdzW107XG5cbiAgLyoqXG4gICAqIEZsb2F0IGJldHdlZW4gMCBhbmQgMTogZnJhY3Rpb24gb2YgdGhlIHRyYWluaW5nIGRhdGFcbiAgICogdG8gYmUgdXNlZCBhcyB2YWxpZGF0aW9uIGRhdGEuIFRoZSBtb2RlbCB3aWxsIHNldCBhcGFydCB0aGlzIGZyYWN0aW9uIG9mXG4gICAqIHRoZSB0cmFpbmluZyBkYXRhLCB3aWxsIG5vdCB0cmFpbiBvbiBpdCwgYW5kIHdpbGwgZXZhbHVhdGUgdGhlIGxvc3MgYW5kXG4gICAqIGFueSBtb2RlbCBtZXRyaWNzIG9uIHRoaXMgZGF0YSBhdCB0aGUgZW5kIG9mIGVhY2ggZXBvY2guXG4gICAqIFRoZSB2YWxpZGF0aW9uIGRhdGEgaXMgc2VsZWN0ZWQgZnJvbSB0aGUgbGFzdCBzYW1wbGVzIGluIHRoZSBgeGAgYW5kIGB5YFxuICAgKiBkYXRhIHByb3ZpZGVkLCBiZWZvcmUgc2h1ZmZsaW5nLlxuICAgKi9cbiAgdmFsaWRhdGlvblNwbGl0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEYXRhIG9uIHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBsb3NzIGFuZCBhbnkgbW9kZWxcbiAgICogbWV0cmljcyBhdCB0aGUgZW5kIG9mIGVhY2ggZXBvY2guIFRoZSBtb2RlbCB3aWxsIG5vdCBiZSB0cmFpbmVkIG9uIHRoaXNcbiAgICogZGF0YS4gVGhpcyBjb3VsZCBiZSBhIHR1cGxlIFt4VmFsLCB5VmFsXSBvciBhIHR1cGxlIFt4VmFsLCB5VmFsLFxuICAgKiB2YWxTYW1wbGVXZWlnaHRzXS4gVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpcyBkYXRhLlxuICAgKiBgdmFsaWRhdGlvbkRhdGFgIHdpbGwgb3ZlcnJpZGUgYHZhbGlkYXRpb25TcGxpdGAuXG4gICAqL1xuICB2YWxpZGF0aW9uRGF0YT86IFtcbiAgICBUZW5zb3J8VGVuc29yW10sIFRlbnNvcnxUZW5zb3JbXVxuICBdfFtUZW5zb3IgfCBUZW5zb3JbXSwgVGVuc29yfFRlbnNvcltdLCBUZW5zb3J8VGVuc29yW11dO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNodWZmbGUgdGhlIHRyYWluaW5nIGRhdGEgYmVmb3JlIGVhY2ggZXBvY2guIEhhc1xuICAgKiBubyBlZmZlY3Qgd2hlbiBgc3RlcHNQZXJFcG9jaGAgaXMgbm90IGBudWxsYC5cbiAgICovXG4gIHNodWZmbGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBvYmplY3QgbWFwcGluZyBjbGFzcyBpbmRpY2VzIChpbnRlZ2VycykgdG9cbiAgICogYSB3ZWlnaHQgKGZsb2F0KSB0byBhcHBseSB0byB0aGUgbW9kZWwncyBsb3NzIGZvciB0aGUgc2FtcGxlcyBmcm9tIHRoaXNcbiAgICogY2xhc3MgZHVyaW5nIHRyYWluaW5nLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gdGVsbCB0aGUgbW9kZWwgdG8gXCJwYXkgbW9yZVxuICAgKiBhdHRlbnRpb25cIiB0byBzYW1wbGVzIGZyb20gYW4gdW5kZXItcmVwcmVzZW50ZWQgY2xhc3MuXG4gICAqXG4gICAqIElmIHRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgb3V0cHV0cywgYSBjbGFzcyB3ZWlnaHQgY2FuIGJlIHNwZWNpZmllZCBmb3JcbiAgICogZWFjaCBvZiB0aGUgb3V0cHV0cyBieSBzZXR0aW5nIHRoaXMgZmllbGQgYW4gYXJyYXkgb2Ygd2VpZ2h0IG9iamVjdFxuICAgKiBvciBhIG9iamVjdCB0aGF0IG1hcHMgbW9kZWwgb3V0cHV0IG5hbWVzIChlLmcuLCBgbW9kZWwub3V0cHV0TmFtZXNbMF1gKVxuICAgKiB0byB3ZWlnaHQgb2JqZWN0cy5cbiAgICovXG4gIGNsYXNzV2VpZ2h0PzogQ2xhc3NXZWlnaHR8Q2xhc3NXZWlnaHRbXXxDbGFzc1dlaWdodE1hcDtcblxuICAvKipcbiAgICogT3B0aW9uYWwgYXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHgsIGNvbnRhaW5pbmdcbiAgICogd2VpZ2h0cyB0byBhcHBseSB0byB0aGUgbW9kZWwncyBsb3NzIGZvciBlYWNoIHNhbXBsZS4gSW4gdGhlIGNhc2Ugb2ZcbiAgICogdGVtcG9yYWwgZGF0YSwgeW91IGNhbiBwYXNzIGEgMkQgYXJyYXkgd2l0aCBzaGFwZSAoc2FtcGxlcyxcbiAgICogc2VxdWVuY2VMZW5ndGgpLCB0byBhcHBseSBhIGRpZmZlcmVudCB3ZWlnaHQgdG8gZXZlcnkgdGltZXN0ZXAgb2YgZXZlcnlcbiAgICogc2FtcGxlLiBJbiB0aGlzIGNhc2UgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gc3BlY2lmeVxuICAgKiBzYW1wbGVXZWlnaHRNb2RlPVwidGVtcG9yYWxcIiBpbiBjb21waWxlKCkuXG4gICAqL1xuICBzYW1wbGVXZWlnaHQ/OiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIEVwb2NoIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYWluaW5nICh1c2VmdWwgZm9yIHJlc3VtaW5nIGEgcHJldmlvdXMgdHJhaW5pbmdcbiAgICogcnVuKS4gV2hlbiB0aGlzIGlzIHVzZWQsIGBlcG9jaHNgIGlzIHRoZSBpbmRleCBvZiB0aGUgXCJmaW5hbCBlcG9jaFwiLlxuICAgKiBUaGUgbW9kZWwgaXMgbm90IHRyYWluZWQgZm9yIGEgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZ2l2ZW4gYnkgYGVwb2Noc2AsXG4gICAqIGJ1dCBtZXJlbHkgdW50aWwgdGhlIGVwb2NoIG9mIGluZGV4IGBlcG9jaHNgIGlzIHJlYWNoZWQuXG4gICAqL1xuICBpbml0aWFsRXBvY2g/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiBzdGVwcyAoYmF0Y2hlcyBvZiBzYW1wbGVzKSBiZWZvcmVcbiAgICogZGVjbGFyaW5nIG9uZSBlcG9jaCBmaW5pc2hlZCBhbmQgc3RhcnRpbmcgdGhlIG5leHQgZXBvY2guIFdoZW4gdHJhaW5pbmdcbiAgICogd2l0aCBJbnB1dCBUZW5zb3JzIHN1Y2ggYXMgVGVuc29yRmxvdyBkYXRhIHRlbnNvcnMsIHRoZSBkZWZhdWx0IGBudWxsYCBpc1xuICAgKiBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBzYW1wbGVzIGluIHlvdXIgZGF0YXNldCBkaXZpZGVkIGJ5IHRoZVxuICAgKiBiYXRjaCBzaXplLCBvciAxIGlmIHRoYXQgY2Fubm90IGJlIGRldGVybWluZWQuXG4gICAqL1xuICBzdGVwc1BlckVwb2NoPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBPbmx5IHJlbGV2YW50IGlmIGBzdGVwc1BlckVwb2NoYCBpcyBzcGVjaWZpZWQuIFRvdGFsIG51bWJlciBvZiBzdGVwc1xuICAgKiAoYmF0Y2hlcyBvZiBzYW1wbGVzKSB0byB2YWxpZGF0ZSBiZWZvcmUgc3RvcHBpbmcuXG4gICAqL1xuICB2YWxpZGF0aW9uU3RlcHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhlIGZyZXF1ZW5jeSBvZiB5aWVsZGluZyB0aGUgbWFpbiB0aHJlYWQgdG8gb3RoZXIgdGFza3MuXG4gICAqXG4gICAqIEluIHRoZSBicm93c2VyIGVudmlyb25tZW50LCB5aWVsZGluZyB0aGUgbWFpbiB0aHJlYWQgY2FuIGltcHJvdmUgdGhlXG4gICAqIHJlc3BvbnNpdmVuZXNzIG9mIHRoZSBwYWdlIGR1cmluZyB0cmFpbmluZy4gSW4gdGhlIE5vZGUuanMgZW52aXJvbm1lbnQsXG4gICAqIGl0IGNhbiBlbnN1cmUgdGFza3MgcXVldWVkIGluIHRoZSBldmVudCBsb29wIGNhbiBiZSBoYW5kbGVkIGluIGEgdGltZWx5XG4gICAqIG1hbm5lci5cbiAgICpcbiAgICogVGhlIHZhbHVlIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogICAtIGAnYXV0bydgOiBUaGUgeWllbGRpbmcgaGFwcGVucyBhdCBhIGNlcnRhaW4gZnJhbWUgcmF0ZSAoY3VycmVudGx5IHNldFxuICAgKiAgICAgICAgICAgICAgIGF0IDEyNW1zKS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAgICogICAtIGAnYmF0Y2gnYDogeWllbGQgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgJ2Vwb2NoJ2A6IHlpZWxkIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYW55IGBudW1iZXJgOiB5aWVsZCBldmVyeSBgbnVtYmVyYCBtaWxsaXNlY29uZHMuXG4gICAqICAgLSBgJ25ldmVyJ2A6IG5ldmVyIHlpZWxkLiAoeWllbGRpbmcgY2FuIHN0aWxsIGhhcHBlbiB0aHJvdWdoIGBhd2FpdFxuICAgKiAgICAgIG5leHRGcmFtZSgpYCBjYWxscyBpbiBjdXN0b20gY2FsbGJhY2tzLilcbiAgICovXG4gIHlpZWxkRXZlcnk/OiBZaWVsZEV2ZXJ5T3B0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQmF0Y2hTaXplKGJhdGNoU2l6ZTogbnVtYmVyKSB7XG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIGJhdGNoU2l6ZSA+IDAgJiYgTnVtYmVyLmlzSW50ZWdlcihiYXRjaFNpemUpLFxuICAgICAgKCkgPT4gYGJhdGNoU2l6ZSBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgJHtcbiAgICAgICAgICBiYXRjaFNpemV9YCk7XG59XG5cbi8qKlxuICogU2xpY2UgYSBUZW5zb3Igb3IgYW4gQXJyYXkgb2YgVGVuc29ycywgYnkgc3RhcnQgYW5kIHN0b3AgaW5kaWNlcy5cbiAqXG4gKiBQb3J0aW5nIE5vdGU6IFRoZSBgX3NsaWNlX2FycmF5c2AgZnVuY3Rpb24gaW4gUHlLZXJhcyBpcyBjb3ZlcmVkIGJ5IHRoaXNcbiAqICAgZnVuY3Rpb24gYW5kIGBzbGljZUFycmF5c0J5SW5kaWNlcygpYCB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0gYXJyYXlzOiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gc3RhcnQ6IHRoZSBzdGFydGluZyBpbmRleCAoaW5jbHVzaXZlKS5cbiAqIEBwYXJhbSBzdG9wOiB0aGUgc3RvcHBpbmcgaW5kZXggKGV4Y2x1c2l2ZSkuXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBzbGljaW5nLiBJZiBgYXJyYXlzYCBpcyBhbiBgQXJyYXlgIG9mXG4gKiAgIGB0Zi5UZW5zb3JgcywgdGhlIHNsaWNpbmcgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBlbGVtZW50cyBvZiB0aGUgYEFycmF5YFxuICogICBpbiB0aGUgc2FtZSB3YXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUFycmF5cyhcbiAgICBhcnJheXM6IFRlbnNvcnxUZW5zb3JbXSwgc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyKTogVGVuc29yfFRlbnNvcltdIHtcbiAgaWYgKGFycmF5cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5cykpIHtcbiAgICByZXR1cm4gYXJyYXlzLm1hcChhcnJheSA9PiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc3RvcCAtIHN0YXJ0KSk7XG4gIH0gZWxzZSB7ICAvLyBUZW5zb3IuXG4gICAgcmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoYXJyYXlzLCBzdGFydCwgc3RvcCAtIHN0YXJ0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNsaWNlIGEgVGVuc29yIG9yIGFuIEFycmF5IG9mIFRlbnNvcnMsIGJ5IHJhbmRvbS1vcmRlciBpbmRpY2VzLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogVGhlIGBfc2xpY2VfYXJyYXlzYCBmdW5jdGlvbiBpbiBQeUtlcmFzIGlzIGNvdmVyZWQgYnkgdGhpc1xuICogICBmdW5jdGlvbiBhbmQgYHNsaWNlQXJyYXlzKClgIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSBhcnJheXMgVGhlIGlucHV0IGB0Zi5UZW5zb3JgIG9yIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzIHRvIHNsaWNlLlxuICogICBJZiBhbiBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcywgYWxsIGB0Zi5UZW5zb3JgcyB3aWxsIGJlIHNsaWNlZCBpbiB0aGVcbiAqICAgc2FtZSBmYXNoaW9uLlxuICogQHBhcmFtIGluZGljZXMgVGhlIGluZGljZXMgdG8gdXNlIGZvciBzbGljaW5nIGFsb25nIHRoZSBmaXJzdCAoYmF0Y2gpXG4gKiAgIGRpbWVuc2lvbi5cbiAqIEByZXR1cm5zIFJlc3VsdChzKSBvZiB0aGUgc2xpY2luZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlQXJyYXlzQnlJbmRpY2VzKFxuICAgIGFycmF5czogVGVuc29yfFRlbnNvcltdLCBpbmRpY2VzOiBUZW5zb3IxRCk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gIHJldHVybiB0ZmMudGlkeSgoKSA9PiB7XG4gICAgaWYgKGFycmF5cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlzKSkge1xuICAgICAgcmV0dXJuIGFycmF5cy5tYXAoXG4gICAgICAgICAgYXJyYXkgPT4gKHNsaWNlQXJyYXlzQnlJbmRpY2VzKGFycmF5LCBpbmRpY2VzKSBhcyBUZW5zb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyhjYWlzKTogaW5kaWNlcyBzaG91bGQgYmUgYSBwcmUtY29uc3RydWN0ZWQgVGVuc29yMUQgdG8gYXZvaWRcbiAgICAgIC8vICAgdGVuc29yMWQoKSBjYWxscy5cbiAgICAgIHJldHVybiBnYXRoZXIoXG4gICAgICAgICAgYXJyYXlzLFxuICAgICAgICAgIGluZGljZXMuZHR5cGUgPT09ICdpbnQzMicgPyBpbmRpY2VzIDogdGZjLmNhc3QoaW5kaWNlcywgJ2ludDMyJykpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYmF0Y2ggaW5kaWNlcyAodHVwbGVzIG9mIGluZGljZXMpLlxuICogQHBhcmFtIHNpemU6IEludGVnZXIsIHRvdGFsIHNpemUgb2YgdGhlIGRhdGEgdG8gc2xpY2UgaW50byBiYXRjaGVzLlxuICogQHBhcmFtIGJhdGNoU2l6ZTogSW50ZWdlciwgYmF0Y2ggc2l6ZS5cbiAqIEByZXR1cm5zIEFuIEFycmF5IG9mIFtiYXRjaFN0YXJ0LCBiYXRjaEVuZF0gdHVwbGVzLiBiYXRjaFN0YXJ0IGlzXG4gKiAgIGluY2x1c2l2ZTsgYmF0Y2hFbmQgaXMgZXhjbHVzaXZlLiBJLmUuLCBlYWNoIGJhdGNoIGNvbnNpc3RzIG9mIGluZGljZXMgeFxuICogICB0aGF0IHNhdGlzZnkgYmF0Y2hTdGFydCA8PSB4IDwgYmF0Y2hFbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQmF0Y2hlcyhcbiAgICBzaXplOiBudW1iZXIsIGJhdGNoU2l6ZTogbnVtYmVyKTogQXJyYXk8W251bWJlciwgbnVtYmVyXT4ge1xuICBjb25zdCBvdXRwdXQ6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG4gIGxldCBiYXRjaFN0YXJ0ID0gMDtcbiAgbGV0IGJhdGNoRW5kOiBudW1iZXIgPSBudWxsO1xuICB3aGlsZSAoYmF0Y2hTdGFydCA8IHNpemUpIHtcbiAgICBiYXRjaEVuZCA9IGJhdGNoU3RhcnQgKyBiYXRjaFNpemU7XG4gICAgaWYgKGJhdGNoRW5kID49IHNpemUpIHtcbiAgICAgIGJhdGNoRW5kID0gc2l6ZTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goW2JhdGNoU3RhcnQsIGJhdGNoRW5kXSk7XG4gICAgYmF0Y2hTdGFydCA9IGJhdGNoRW5kO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgZml0IGZ1bmN0aW9uIGZvciBgZihpbnMpYC5cbiAqIEBwYXJhbSBmIEEgRnVuY3Rpb24gcmV0dXJuaW5nIGEgbGlzdCBvZiB0ZW5zb3JzLiBGb3IgdHJhaW5pbmcsIHRoaXNcbiAqICAgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcGVyZm9ybSB0aGUgdXBkYXRlcyB0byB0aGUgdmFyaWFibGVzLlxuICogQHBhcmFtIGlucyBMaXN0IG9mIHRlbnNvcnMgdG8gYmUgZmVkIHRvIGBmYC5cbiAqIEBwYXJhbSBvdXRMYWJlbHMgTGlzdCBvZiBzdHJpbmdzLCBkaXNwbGF5IG5hbWVzIG9mIHRoZSBvdXRwdXRzIG9mIGBmYC5cbiAqIEBwYXJhbSBiYXRjaFNpemUgSW50ZWdlciBiYXRjaCBzaXplIG9yIGA9PSBudWxsYCBpZiB1bmtub3duLiBEZWZhdWx0IDogMzIuXG4gKiBAcGFyYW0gZXBvY2hzIE51bWJlciBvZiB0aW1lcyB0byBpdGVyYXRlIG92ZXIgdGhlIGRhdGEuIERlZmF1bHQgOiAxLlxuICogQHBhcmFtIHZlcmJvc2UgVmVyYm9zaXR5IG1vZGU6IDAsIDEsIG9yIDIuIERlZmF1bHQ6IDEuXG4gKiBAcGFyYW0gY2FsbGJhY2tzIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCBkdXJpbmcgdHJhaW5pbmcuXG4gKiBAcGFyYW0gdmFsRiBGdW5jdGlvbiB0byBjYWxsIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHZhbElucyBMaXN0IG9mIHRlbnNvcnMgdG8gYmUgZmVkIHRvIGB2YWxGYC5cbiAqIEBwYXJhbSBzaHVmZmxlIFdoZXRoZXIgdG8gc2h1ZmZsZSB0aGUgZGF0YSBhdCB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5XG4gKiBlcG9jaC4gRGVmYXVsdCA6IHRydWUuXG4gKiBAcGFyYW0gY2FsbGJhY2tNZXRyaWNzIExpc3Qgb2Ygc3RyaW5ncywgdGhlIGRpc3BsYXkgbmFtZXMgb2YgdGhlIG1ldHJpY3NcbiAqICAgcGFzc2VkIHRvIHRoZSBjYWxsYmFja3MuIFRoZXkgc2hvdWxkIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogICBkaXNwbGF5IG5hbWVzIG9mIHRoZSBvdXRwdXRzIG9mIGBmYCBhbmQgdGhlIGxpc3Qgb2YgZGlzcGxheSBuYW1lc1xuICogICBvZiB0aGUgb3V0cHV0cyBvZiBgdmFsRmAuXG4gKiBAcGFyYW0gaW5pdGlhbEVwb2NoIEVwb2NoIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYWluaW5nICh1c2VmdWwgZm9yXG4gKiAgIHJlc3VtaW5nIGEgcHJldmlvdXMgdHJhaW5pbmcgcnVuKS4gRGVmYXVsdCA6IDAuXG4gKiBAcGFyYW0gc3RlcHNQZXJFcG9jaCBUb3RhbCBudW1iZXIgb2Ygc3RlcHMgKGJhdGNoZXMgb24gc2FtcGxlcykgYmVmb3JlXG4gKiAgIGRlY2xhcmluZyBvbmUgZXBvY2ggZmluaXNoZWQgYW5kIHN0YXJ0aW5nIHRoZSBuZXh0IGVwb2NoLiBJZ25vcmVkIHdpdGhcbiAqICAgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYHVuZGVmaW5lZGAgb3IgYG51bGxgLlxuICogQHBhcmFtIHZhbGlkYXRpb25TdGVwcyBOdW1iZXIgb2Ygc3RlcHMgdG8gcnVuIHZhbGlkYXRpb24gZm9yIChvbmx5IGlmXG4gKiAgIGRvaW5nIHZhbGlkYXRpb24gZnJvbSBkYXRhIHRlbnNvcnMpLiBOb3QgYXBwbGljYWJsZSBmb3IgdGZqcy1sYXllcnMuXG4gKiBAcmV0dXJucyBBIGBIaXN0b3J5YCBvYmplY3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpdExvb3AoXG4gICAgLy8gVHlwZSBgbW9kZWxgIGFzIGBhbnlgIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3LyB0cmFpbmluZy50cy5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgbW9kZWw6IGFueSwgZjogKGRhdGE6IFRlbnNvcltdKSA9PiBTY2FsYXJbXSwgaW5zOiBUZW5zb3JbXSxcbiAgICBvdXRMYWJlbHM/OiBzdHJpbmdbXSwgYmF0Y2hTaXplPzogbnVtYmVyLCBlcG9jaHM/OiBudW1iZXIsIHZlcmJvc2U/OiBudW1iZXIsXG4gICAgY2FsbGJhY2tzPzogQmFzZUNhbGxiYWNrW10sIHZhbEY/OiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdLFxuICAgIHZhbElucz86IFRlbnNvcltdLCBzaHVmZmxlPzogYm9vbGVhbnxzdHJpbmcsIGNhbGxiYWNrTWV0cmljcz86IHN0cmluZ1tdLFxuICAgIGluaXRpYWxFcG9jaD86IG51bWJlciwgc3RlcHNQZXJFcG9jaD86IG51bWJlcixcbiAgICB2YWxpZGF0aW9uU3RlcHM/OiBudW1iZXIpOiBQcm9taXNlPEhpc3Rvcnk+IHtcbiAgaWYgKGJhdGNoU2l6ZSA9PSBudWxsKSB7XG4gICAgYmF0Y2hTaXplID0gMzI7XG4gIH1cbiAgaWYgKGVwb2NocyA9PSBudWxsKSB7XG4gICAgZXBvY2hzID0gMTtcbiAgfVxuICBpZiAoc2h1ZmZsZSA9PSBudWxsKSB7XG4gICAgc2h1ZmZsZSA9IHRydWU7XG4gIH1cbiAgaWYgKGluaXRpYWxFcG9jaCA9PSBudWxsKSB7XG4gICAgaW5pdGlhbEVwb2NoID0gMDtcbiAgfVxuXG4gIC8vIFRPRE8oY2Fpcyk6IENoYW5nZSBjb25zdCB0byBsZXQgYmVsb3cgd2hlbiBpbXBsZW1lbnRpbmcgdmFsaWRhdGlvbi5cbiAgbGV0IGRvVmFsaWRhdGlvbiA9IGZhbHNlO1xuICBpZiAodmFsRiAhPSBudWxsICYmIHZhbElucyAhPSBudWxsKSB7XG4gICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAvLyBUT0RPKGNhaXMpOiB2ZXJib3NlIG1lc3NhZ2UuXG4gIH1cbiAgaWYgKHZhbGlkYXRpb25TdGVwcyAhPSBudWxsKSB7XG4gICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICBpZiAoc3RlcHNQZXJFcG9jaCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnQ2FuIG9ubHkgdXNlIGB2YWxpZGF0aW9uU3RlcHNgIHdoZW4gZG9pbmcgc3RlcC13aXNlIHRyYWluaW5nLCAnICtcbiAgICAgICAgICAnaS5lLiwgYHN0ZXBzUGVyRXBvY2hgIG11c3QgYmUgc2V0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG51bVRyYWluU2FtcGxlcyA9XG4gICAgICBtb2RlbC5jaGVja051bVNhbXBsZXMoaW5zLCBiYXRjaFNpemUsIHN0ZXBzUGVyRXBvY2gsICdzdGVwc19wZXJfZXBvY2gnKTtcbiAgbGV0IGluZGV4QXJyYXk6IG51bWJlcltdO1xuICBpZiAobnVtVHJhaW5TYW1wbGVzICE9IG51bGwpIHtcbiAgICBpbmRleEFycmF5ID0gcmFuZ2UoMCwgbnVtVHJhaW5TYW1wbGVzKTtcbiAgfVxuXG4gIGlmICh2ZXJib3NlID09IG51bGwpIHtcbiAgICB2ZXJib3NlID0gMTtcbiAgfVxuXG4gIGNvbnN0IHtjYWxsYmFja0xpc3QsIGhpc3Rvcnl9ID0gY29uZmlndXJlQ2FsbGJhY2tzKFxuICAgICAgY2FsbGJhY2tzLCB2ZXJib3NlLCBlcG9jaHMsIGluaXRpYWxFcG9jaCwgbnVtVHJhaW5TYW1wbGVzLCBzdGVwc1BlckVwb2NoLFxuICAgICAgYmF0Y2hTaXplLCBkb1ZhbGlkYXRpb24sIGNhbGxiYWNrTWV0cmljcyk7XG4gIGNhbGxiYWNrTGlzdC5zZXRNb2RlbChtb2RlbCk7XG4gIG1vZGVsLmhpc3RvcnkgPSBoaXN0b3J5O1xuICBhd2FpdCBjYWxsYmFja0xpc3Qub25UcmFpbkJlZ2luKCk7XG4gIG1vZGVsLnN0b3BUcmFpbmluZ18gPSBmYWxzZTtcbiAgLy8gVE9ETyhjYWlzKTogVGFrZSBjYXJlIG9mIGNhbGxiYWNrcy52YWxpZGF0aW9uX2RhdGEgYXMgaW4gUHlLZXJhcy5cbiAgLy8gVE9ETyhjYWlzKTogUHJlLWNvbnZlcnQgZmVlZHMgZm9yIHBlcmZvcm1hbmNlIGFzIGluIFB5S2VyYXMuXG5cbiAgZm9yIChsZXQgZXBvY2ggPSBpbml0aWFsRXBvY2g7IGVwb2NoIDwgZXBvY2hzOyArK2Vwb2NoKSB7XG4gICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uRXBvY2hCZWdpbihlcG9jaCk7XG4gICAgY29uc3QgZXBvY2hMb2dzOiBVbnJlc29sdmVkTG9ncyA9IHt9O1xuICAgIGlmIChzdGVwc1BlckVwb2NoICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICdzdGVwc1BlckVwb2NoIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNodWZmbGUgPT09ICdiYXRjaCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2JhdGNoIHNodWZmbGluZyBpcyBub3QgaW1wbGVtbmV0ZWQgeWV0Jyk7XG4gICAgICB9IGVsc2UgaWYgKHNodWZmbGUpIHtcbiAgICAgICAgdXRpbC5zaHVmZmxlKGluZGV4QXJyYXkpO1xuICAgICAgfVxuICAgICAgLy8gQ29udmVydCB0aGUgcG90ZW50aWFsbHkgc2h1ZmZsZWQgaW5kaWNlcyB0byBUZW5zb3IxRCwgdG8gYXZvaWQgdGhlXG4gICAgICAvLyBjb3N0IG9mIHJlcGVhdGVkIGNyZWF0aW9uIG9mIEFycmF5MURzIGxhdGVyIG9uLlxuICAgICAgY29uc3QgZXBvY2hJbmRleEFycmF5MUQgPSB0ZW5zb3IxZChpbmRleEFycmF5KTtcblxuICAgICAgY29uc3QgYmF0Y2hlcyA9IG1ha2VCYXRjaGVzKG51bVRyYWluU2FtcGxlcywgYmF0Y2hTaXplKTtcbiAgICAgIGZvciAobGV0IGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgYmF0Y2hlcy5sZW5ndGg7ICsrYmF0Y2hJbmRleCkge1xuICAgICAgICBjb25zdCBiYXRjaExvZ3M6IFVucmVzb2x2ZWRMb2dzID0ge307XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkJhdGNoQmVnaW4oYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKTtcblxuICAgICAgICB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmF0Y2hTdGFydCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMF07XG4gICAgICAgICAgY29uc3QgYmF0Y2hFbmQgPSBiYXRjaGVzW2JhdGNoSW5kZXhdWzFdO1xuICAgICAgICAgIGNvbnN0IGJhdGNoSWRzID0gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcG9jaEluZGV4QXJyYXkxRCwgYmF0Y2hTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaEVuZCAtIGJhdGNoU3RhcnQpIGFzIFRlbnNvcjFEO1xuICAgICAgICAgIGJhdGNoTG9nc1snYmF0Y2gnXSA9IGJhdGNoSW5kZXg7XG4gICAgICAgICAgYmF0Y2hMb2dzWydzaXplJ10gPSBiYXRjaEVuZCAtIGJhdGNoU3RhcnQ7XG5cbiAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBJbiBpbnMsIHRyYWluIGZsYWcgY2FuIGJlIGEgbnVtYmVyLCBpbnN0ZWFkIG9mIGFuXG4gICAgICAgICAgLy8gICBUZW5zb3I/IERvIHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgaW4gdGZqcy1sYXllcnM/XG4gICAgICAgICAgY29uc3QgaW5zQmF0Y2ggPSBzbGljZUFycmF5c0J5SW5kaWNlcyhpbnMsIGJhdGNoSWRzKSBhcyBUZW5zb3JbXTtcbiAgICAgICAgICBjb25zdCBvdXRzID0gZihpbnNCYXRjaCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gb3V0TGFiZWxzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gb3V0c1tpXTtcbiAgICAgICAgICAgIGJhdGNoTG9nc1tsYWJlbF0gPSBvdXQ7XG4gICAgICAgICAgICB0ZmMua2VlcChvdXQpO1xuICAgICAgICAgICAgLy8gVE9ETyhjYWlzKTogVXNlIHNjb3BlKCkgdG8gYXZvaWQgb3duZXJzaGlwLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChiYXRjaEluZGV4ID09PSBiYXRjaGVzLmxlbmd0aCAtIDEpIHsgIC8vIExhc3QgYmF0Y2guXG4gICAgICAgICAgICBpZiAoZG9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbE91dHMgPSBtb2RlbC50ZXN0TG9vcCh2YWxGLCB2YWxJbnMsIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgIC8vIFBvcnRpbmcgTm90ZXM6IEluIHRmanMtbGF5ZXJzLCB2YWxPdXRzIGlzIGFsd2F5cyBhbiBBcnJheS5cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IG91dExhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB2YWxPdXRzW2ldO1xuICAgICAgICAgICAgICAgIHRmYy5rZWVwKG91dCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhjYWlzKTogVXNlIHNjb3BlKCkgdG8gYXZvaWQgb3duZXJzaGlwLlxuICAgICAgICAgICAgICAgIGVwb2NoTG9nc1sndmFsXycgKyBsYWJlbF0gPSBvdXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkJhdGNoRW5kKGJhdGNoSW5kZXgsIGJhdGNoTG9ncyk7XG4gICAgICAgIGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGJhdGNoTG9ncyk7XG5cbiAgICAgICAgaWYgKG1vZGVsLnN0b3BUcmFpbmluZ18pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGNhaXMpOiByZXR1cm4gb3V0cyBhcyBsaXN0IG9mIFRlbnNvci5cbiAgICAgIH1cblxuICAgICAgZXBvY2hJbmRleEFycmF5MUQuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvLyBUT0RPKGNhaXMpOiBSdW4gdmFsaWRhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBlcG9jaC5cbiAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25FcG9jaEVuZChlcG9jaCwgZXBvY2hMb2dzKTtcbiAgICBpZiAobW9kZWwuc3RvcFRyYWluaW5nXykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGF3YWl0IGNhbGxiYWNrTGlzdC5vblRyYWluRW5kKCk7XG5cbiAgYXdhaXQgbW9kZWwuaGlzdG9yeS5zeW5jRGF0YSgpO1xuICByZXR1cm4gbW9kZWwuaGlzdG9yeTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpdFRlbnNvcnMoXG4gICAgLy8gVHlwZSBgbW9kZWxgIGFzIGBhbnlgIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3LyB0cmFpbmluZy50cy5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgbW9kZWw6IGFueSwgeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgIHk6IFRlbnNvcnxUZW5zb3JbXXx7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSxcbiAgICBhcmdzOiBNb2RlbEZpdEFyZ3MgPSB7fSk6IFByb21pc2U8SGlzdG9yeT4ge1xuICBpZiAobW9kZWwuaXNUcmFpbmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBzdGFydCB0cmFpbmluZyBiZWNhdXNlIGFub3RoZXIgZml0KCkgY2FsbCBpcyBvbmdvaW5nLicpO1xuICB9XG4gIG1vZGVsLmlzVHJhaW5pbmcgPSB0cnVlO1xuICBsZXQgaW5wdXRzOiBUZW5zb3JbXTtcbiAgbGV0IHRhcmdldHM6IFRlbnNvcltdO1xuICBsZXQgaW5wdXRWYWxYOiBUZW5zb3J8VGVuc29yW107XG4gIGxldCBpbnB1dFZhbFk6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHZhbFg6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHZhbFk6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHNhbXBsZVdlaWdodHM6IFRlbnNvcltdO1xuICB0cnkge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGFyZ3MuYmF0Y2hTaXplID09IG51bGwgPyAzMiA6IGFyZ3MuYmF0Y2hTaXplO1xuICAgIGNoZWNrQmF0Y2hTaXplKGJhdGNoU2l6ZSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB1c2VyIGRhdGEuXG4gICAgLy8gVE9ETyhjYWlzKTogU3VwcG9ydCBzYW1wbGVXZWlnaHQuXG4gICAgY29uc3QgY2hlY2tCYXRjaEF4aXMgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFuZGFyZGl6ZWRPdXRzID1cbiAgICAgICAgYXdhaXQgbW9kZWwuc3RhbmRhcmRpemVVc2VyRGF0YShcbiAgICAgICAgICAgIHgsIHksIGFyZ3Muc2FtcGxlV2VpZ2h0LCBhcmdzLmNsYXNzV2VpZ2h0LCBjaGVja0JhdGNoQXhpcyxcbiAgICAgICAgICAgIGJhdGNoU2l6ZSkgYXMgW1RlbnNvcltdLCBUZW5zb3JbXSwgVGVuc29yW11dO1xuICAgIGlucHV0cyA9IHN0YW5kYXJkaXplZE91dHNbMF07XG4gICAgdGFyZ2V0cyA9IHN0YW5kYXJkaXplZE91dHNbMV07XG4gICAgc2FtcGxlV2VpZ2h0cyA9IHN0YW5kYXJkaXplZE91dHNbMl07XG5cbiAgICAvLyBQcmVwYXJlIHZhbGlkYXRpb24gZGF0YS5cbiAgICBsZXQgZG9WYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgbGV0IHZhbEluczogVGVuc29yW107XG4gICAgaWYgKGFyZ3MudmFsaWRhdGlvbkRhdGEgIT0gbnVsbCAmJiBhcmdzLnZhbGlkYXRpb25EYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRvVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICBpZiAoYXJncy52YWxpZGF0aW9uRGF0YS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gY29uZmlnLnZhbGlkYXRpb25EYXRhIGNvbnNpc3RzIG9mIHZhbFggYW5kIHZhbFkuXG4gICAgICAgIGlucHV0VmFsWCA9IGFyZ3MudmFsaWRhdGlvbkRhdGFbMF07XG4gICAgICAgIGlucHV0VmFsWSA9IGFyZ3MudmFsaWRhdGlvbkRhdGFbMV07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MudmFsaWRhdGlvbkRhdGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFdoZW4gcGFzc2luZyB2YWxpZGF0aW9uIGRhdGEsIGl0IG11c3QgY29udGFpbiAyICh2YWxYLCB2YWxZKSBgICtcbiAgICAgICAgICAgIGBvciAzICh2YWxYLCB2YWxZLCB2YWxTYW1wbGVXZWlnaHQpIGl0ZW1zOyBgICtcbiAgICAgICAgICAgIGAke2FyZ3MudmFsaWRhdGlvbkRhdGF9IGlzIGludmFsaWQuYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoZWNrQmF0Y2hBeGlzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHZhbFN0YW5kYXJkaXplZCA9XG4gICAgICAgICAgYXdhaXQgbW9kZWwuc3RhbmRhcmRpemVVc2VyRGF0YShcbiAgICAgICAgICAgICAgaW5wdXRWYWxYLCBpbnB1dFZhbFksIG51bGwsIC8qKiBVbnVzZWQgc2FtcGxlIHdlaWdodHMuICovXG4gICAgICAgICAgICAgIG51bGwsICAgICAgICAgICAgICAgICAgICAgICAvKiogVW51c2VkIGNsYXNzIHdlaWdodHMuICovXG4gICAgICAgICAgICAgIGNoZWNrQmF0Y2hBeGlzLCBiYXRjaFNpemUpIGFzIFtUZW5zb3JbXSwgVGVuc29yW10sIFRlbnNvcltdXTtcbiAgICAgIHZhbFggPSB2YWxTdGFuZGFyZGl6ZWRbMF07XG4gICAgICB2YWxZID0gdmFsU3RhbmRhcmRpemVkWzFdO1xuICAgICAgdmFsSW5zID0gdmFsWC5jb25jYXQodmFsWSk7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdXNlTGVhcm5pbmdQaGFzZSBkYXRhIHByb3Blcmx5LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGFyZ3MudmFsaWRhdGlvblNwbGl0ICE9IG51bGwgJiYgYXJncy52YWxpZGF0aW9uU3BsaXQgPiAwICYmXG4gICAgICAgIGFyZ3MudmFsaWRhdGlvblNwbGl0IDwgMSkge1xuICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIFBvcnRpbmcgTm90ZTogSW4gdGZqcy1sYXllcnMsIGlucHV0c1swXSBpcyBhbHdheXMgYSBUZW5zb3IuXG4gICAgICBjb25zdCBzcGxpdEF0ID1cbiAgICAgICAgICBNYXRoLmZsb29yKGlucHV0c1swXS5zaGFwZVswXSAqICgxIC0gYXJncy52YWxpZGF0aW9uU3BsaXQpKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQmF0Y2hTaXplID0gaW5wdXRzWzBdLnNoYXBlWzBdO1xuICAgICAgdmFsWCA9IHNsaWNlQXJyYXlzKGlucHV0cywgc3BsaXRBdCwgb3JpZ2luYWxCYXRjaFNpemUpIGFzIFRlbnNvcltdO1xuICAgICAgaW5wdXRzID0gc2xpY2VBcnJheXMoaW5wdXRzLCAwLCBzcGxpdEF0KSBhcyBUZW5zb3JbXTtcbiAgICAgIHZhbFkgPSBzbGljZUFycmF5cyh0YXJnZXRzLCBzcGxpdEF0LCBvcmlnaW5hbEJhdGNoU2l6ZSkgYXMgVGVuc29yW107XG4gICAgICB0YXJnZXRzID0gc2xpY2VBcnJheXModGFyZ2V0cywgMCwgc3BsaXRBdCkgYXMgVGVuc29yW107XG4gICAgICAvLyBUT0RPKGNhaXMpOiBPbmNlIHNhbXBsZVdlaWdodHMgYmVjb21lcyBhdmFpbGFibGUsIHNsaWNlIGl0IHRvIGdldFxuICAgICAgLy8gICB2YWxTYW1wbGVXZWlnaHRzLlxuICAgICAgdmFsSW5zID0gdmFsWC5jb25jYXQodmFsWSk7XG5cbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCB1c2VMZWFybmluZ1BoYXNlIGRhdGEgcHJvcGVybHkuXG4gICAgfSBlbHNlIGlmIChhcmdzLnZhbGlkYXRpb25TdGVwcyAhPSBudWxsKSB7XG4gICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIHVzZUxlYXJuaW5nUGhhc2UuXG4gICAgfVxuXG4gICAgY29uc3QgaW5zID0gaW5wdXRzLmNvbmNhdCh0YXJnZXRzKS5jb25jYXQoc2FtcGxlV2VpZ2h0cyk7XG5cbiAgICBtb2RlbC5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpO1xuXG4gICAgLy8gVE9ETyhjYWlzKTogSGFuZGxlIHVzZV9sZWFybmluZ19waGFzZSBhbmQgbGVhcm5pbmdfcGhhc2U/XG5cbiAgICAvLyBQb3J0aW5nIE5vdGU6IEhlcmUgd2Ugc2VlIGEga2V5IGRldmlhdGlvbiBvZiB0ZmpzLWxheWVycyBmcm9tXG4gICAgLy8gS2VyYXMuXG4gICAgLy8gIER1ZSB0byB0aGUgaW1wZXJhdGl2ZSBuYXR1cmUgb2YgdGZqcy1sYXllcnMnIGJhY2tlbmQgKHRmanMtY29yZSksXG4gICAgLy8gIHdlIGRvIG5vdCBjb25zdHJ1Y3Qgc3ltYm9saWMgY29tcHV0YXRpb24gZ3JhcGhzIHRvIGVtYm9keSB0aGVcbiAgICAvLyAgdHJhaW5pbmcgcHJvY2Vzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGVcbiAgICAvLyAgdHJhaW5pbmcgYWN0aW9uLiBJbiBQeUtlcmFzLCB0aGUgZGF0YSAoaW5wdXRzIGFuZCB0YXJnZXRzKSBhcmUgZmVkXG4gICAgLy8gIHRocm91Z2ggZ3JhcGggcGxhY2Vob2xkZXJzLiBJbiB0ZmpzLWxheWVycywgdGhlIGRhdGEgYXJlIGZlZCBhc1xuICAgIC8vICBmdW5jdGlvbiBhcmd1bWVudHMuIFNpbmNlIHRoZSBmdW5jdGlvbiBhcmUgZGVmaW5lZCBiZWxvdyBpbiB0aGVcbiAgICAvLyAgc2NvcGUsIHdlIGRvbid0IGhhdmUgZXF1aXZhbGVudHMgb2YgUHlLZXJhcydzXG4gICAgLy8gIGBfbWFrZV90cmFpbl9mdW5jaXRvbmAuXG4gICAgY29uc3QgdHJhaW5GdW5jdGlvbiA9IG1vZGVsLm1ha2VUcmFpbkZ1bmN0aW9uKCk7XG4gICAgY29uc3Qgb3V0TGFiZWxzID0gbW9kZWwuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpIGFzIHN0cmluZ1tdO1xuXG4gICAgbGV0IHZhbEZ1bmN0aW9uOiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdO1xuICAgIGxldCBjYWxsYmFja01ldHJpY3M6IHN0cmluZ1tdO1xuICAgIGlmIChkb1ZhbGlkYXRpb24pIHtcbiAgICAgIG1vZGVsLm1ha2VUZXN0RnVuY3Rpb24oKTtcbiAgICAgIHZhbEZ1bmN0aW9uID0gbW9kZWwudGVzdEZ1bmN0aW9uO1xuICAgICAgY2FsbGJhY2tNZXRyaWNzID1cbiAgICAgICAgICBvdXRMYWJlbHMuc2xpY2UoKS5jb25jYXQob3V0TGFiZWxzLm1hcChuID0+ICd2YWxfJyArIG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsRnVuY3Rpb24gPSBudWxsO1xuICAgICAgdmFsSW5zID0gW107XG4gICAgICBjYWxsYmFja01ldHJpY3MgPSBvdXRMYWJlbHMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFja3MgPSBzdGFuZGFyZGl6ZUNhbGxiYWNrcyhhcmdzLmNhbGxiYWNrcywgYXJncy55aWVsZEV2ZXJ5KTtcbiAgICBjb25zdCBvdXQgPSBhd2FpdCBmaXRMb29wKFxuICAgICAgICBtb2RlbCwgdHJhaW5GdW5jdGlvbiwgaW5zLCBvdXRMYWJlbHMsIGJhdGNoU2l6ZSwgYXJncy5lcG9jaHMsXG4gICAgICAgIGFyZ3MudmVyYm9zZSwgY2FsbGJhY2tzLCB2YWxGdW5jdGlvbiwgdmFsSW5zLCBhcmdzLnNodWZmbGUsXG4gICAgICAgIGNhbGxiYWNrTWV0cmljcywgYXJncy5pbml0aWFsRXBvY2gsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0gZmluYWxseSB7XG4gICAgbW9kZWwuaXNUcmFpbmluZyA9IGZhbHNlO1xuICAgIC8vIE1lbW9yeSBjbGVhbiB1cC5cbiAgICBkaXNwb3NlTmV3VGVuc29ycyhpbnB1dHMsIHgpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHRhcmdldHMsIHkpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHZhbFggYXMgVGVuc29yW10sIGlucHV0VmFsWCk7XG4gICAgZGlzcG9zZU5ld1RlbnNvcnModmFsWSBhcyBUZW5zb3JbXSwgaW5wdXRWYWxZKTtcbiAgICBpZiAoc2FtcGxlV2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICB0ZmMuZGlzcG9zZShzYW1wbGVXZWlnaHRzKTtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETyhjYWlzKTogQWRkIHZhbHVlIHRvIG91dExhYmVscy5cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGVuc29ycyBhbGwgaGF2ZSBhIHJhbmsgb2YgYXQgbGVhc3QgMi5cbiAqXG4gKiBJZiBhIHRlbnNvciBoYXMgYSByYW5rIG9mIDEsIGl0IGlzIGRpbWVuc2lvbi1leHBhbmRlZCB0byByYW5rIDIuXG4gKiBJZiBhbnkgdGVuc29yIGhhcyBhIHJhbmsgb2YgMCAoaS5lLiwgaXMgYSBzY2FsYXIpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKHRlbnNvcnM6IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgY29uc3Qgb3V0czogVGVuc29yW10gPSBbXTtcbiAgaWYgKHRlbnNvcnMgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICB0ZW5zb3JzID0gW3RlbnNvcnNdO1xuICB9XG5cbiAgLy8gTWFrZSBUZW5zb3JzIGF0IGxlYXN0IDJELlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB0ZW5zb3IgPSB0ZW5zb3JzW2ldO1xuICAgIGlmICh0ZW5zb3IucmFuayA9PT0gMSkge1xuICAgICAgb3V0cy5wdXNoKGV4cGFuZERpbXModGVuc29yLCAxKSk7XG4gICAgfSBlbHNlIGlmICh0ZW5zb3IucmFuayA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCB0ZW5zb3IgdG8gYmUgYXQgbGVhc3QgMUQsIGJ1dCByZWNlaXZlZCBhIDBEIHRlbnNvciAnICtcbiAgICAgICAgICAnKHNjYWxhcikuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHMucHVzaCh0ZW5zb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cztcbn1cblxuLyoqXG4gKiBDb21wYXJlIGEgc2V0IG9mIHRlbnNvcnMgd2l0aCBhIHJlZmVyZW5jZSAob2xkKSBzZXQsIGRpc2NhcmQgdGhlIG9uZXNcbiAqIGluIHRoZSBuZXcgc2V0IHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSByZWZlcmVuY2Ugc2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIG1lbW9yeSBjbGVuYXVwIGR1cmluZyBjYWxscyBzdWNoIGFzXG4gKiBMYXllcnNNb2RlbC5maXQoKS5cbiAqXG4gKiBAcGFyYW0gdGVuc29ycyBOZXcgc2V0IHdoaWNoIG1heSBjb250YWluIFRlbnNvcnMgbm90IHByZXNlbnQgaW5cbiAqICAgYHJlZlRlbnNvcnNgLlxuICogQHBhcmFtIHJlZlRlbnNvcnMgUmVmZXJlbmNlIFRlbnNvciBzZXQuXG4gKi9cbi8vIFRPRE8oY2Fpcywga2FuZ3lpemhhbmcpOiBEZWR1cGxpY2F0ZSB3aXRoIHRmanMtZGF0YS5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlTmV3VGVuc29ycyhcbiAgICB0ZW5zb3JzOiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sXG4gICAgcmVmVGVuc29yczogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9KTogdm9pZCB7XG4gIGlmICh0ZW5zb3JzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkVGVuc29ySWRzOiBudW1iZXJbXSA9IFtdO1xuICBpZiAocmVmVGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIG9sZFRlbnNvcklkcy5wdXNoKHJlZlRlbnNvcnMuaWQpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVmVGVuc29ycykpIHtcbiAgICByZWZUZW5zb3JzLmZvckVhY2godCA9PiBvbGRUZW5zb3JJZHMucHVzaCh0LmlkKSk7XG4gIH0gZWxzZSBpZiAocmVmVGVuc29ycyAhPSBudWxsKSB7XG4gICAgLy8gYG9sZFRlbnNvcnNgIGlzIGEgbWFwIGZyb20gc3RyaW5nIG5hbWUgdG8gVGVuc29yLlxuICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWZUZW5zb3JzKSB7XG4gICAgICBjb25zdCBvbGRUZW5zb3IgPSByZWZUZW5zb3JzW25hbWVdO1xuICAgICAgb2xkVGVuc29ySWRzLnB1c2gob2xkVGVuc29yLmlkKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0ZW5zb3JzVG9EaXNwb3NlOiBUZW5zb3JbXSA9IFtdO1xuICBpZiAodGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3JzLmlkKSA9PT0gLTEpIHtcbiAgICAgIHRlbnNvcnNUb0Rpc3Bvc2UucHVzaCh0ZW5zb3JzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZW5zb3JzKSkge1xuICAgIHRlbnNvcnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0LmlkKSA9PT0gLTEpIHtcbiAgICAgICAgdGVuc29yc1RvRGlzcG9zZS5wdXNoKHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRlbnNvcnMgIT0gbnVsbCkge1xuICAgIC8vIGBvbGRUZW5zb3JzYCBpcyBhIG1hcCBmcm9tIHN0cmluZyBuYW1lIHRvIFRlbnNvci5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVuc29ycykge1xuICAgICAgY29uc3QgdGVuc29yID0gdGVuc29yc1tuYW1lXTtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3IuaWQpID09PSAtMSkge1xuICAgICAgICB0ZW5zb3JzVG9EaXNwb3NlLnB1c2godGVuc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZW5zb3JzVG9EaXNwb3NlLmZvckVhY2godCA9PiB7XG4gICAgaWYgKCF0LmlzRGlzcG9zZWQpIHtcbiAgICAgIHQuZGlzcG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=